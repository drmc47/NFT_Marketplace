"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeCommand = exports.transformCommandArguments = exports.extendWithModulesAndScripts = exports.extendWithDefaultCommands = void 0;
const commands_1 = __importDefault(require("./commands"));
const command_options_1 = require("./command-options");
function extendWithDefaultCommands(BaseClass, executor) {
    for (const [name, command] of Object.entries(commands_1.default)) {
        BaseClass.prototype[name] = function (...args) {
            return executor.call(this, command, args);
        };
    }
}
exports.extendWithDefaultCommands = extendWithDefaultCommands;
function extendWithModulesAndScripts(config) {
    let Commander;
    if (config.modules) {
        Commander = class extends config.BaseClass {
            constructor(...args) {
                super(...args);
                for (const module of Object.keys(config.modules)) {
                    this[module] = new this[module](this);
                }
            }
        };
        for (const [moduleName, module] of Object.entries(config.modules)) {
            Commander.prototype[moduleName] = class {
                constructor(self) {
                    Object.defineProperty(this, "self", {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: void 0
                    });
                    this.self = self;
                }
            };
            for (const [commandName, command] of Object.entries(module)) {
                Commander.prototype[moduleName].prototype[commandName] = function (...args) {
                    return config.modulesCommandsExecutor.call(this.self, command, args);
                };
            }
        }
    }
    if (config.scripts) {
        Commander !== null && Commander !== void 0 ? Commander : (Commander = class extends config.BaseClass {
        });
        for (const [name, script] of Object.entries(config.scripts)) {
            Commander.prototype[name] = function (...args) {
                return config.scriptsExecutor.call(this, script, args);
            };
        }
    }
    return (Commander !== null && Commander !== void 0 ? Commander : config.BaseClass);
}
exports.extendWithModulesAndScripts = extendWithModulesAndScripts;
function transformCommandArguments(command, args) {
    let options;
    if (command_options_1.isCommandOptions(args[0])) {
        options = args[0];
        args = args.slice(1);
    }
    return {
        args: command.transformArguments(...args),
        options
    };
}
exports.transformCommandArguments = transformCommandArguments;
function encodeCommand(args) {
    const encoded = [
        `*${args.length}`,
        `$${Buffer.byteLength(args[0])}`,
        args[0]
    ];
    for (let i = 1; i < args.length; i++) {
        encoded.push(`$${Buffer.byteLength(args[i])}`, args[i]);
    }
    return encoded.join('\r\n') + '\r\n';
}
exports.encodeCommand = encodeCommand;
