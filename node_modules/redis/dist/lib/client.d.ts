/// <reference types="node" />
import { RedisSocketOptions } from './socket';
import { PubSubListener, QueueCommandOptions } from './commands-queue';
import COMMANDS from './commands';
import { RedisCommand, RedisModules, RedisReply } from './commands';
import { RedisMultiCommandType } from './multi-command';
import EventEmitter from 'events';
import { CommandOptions } from './command-options';
import { RedisLuaScript, RedisLuaScripts } from './lua-script';
import { ScanOptions, ZMember } from './commands/generic-transformers';
import { ScanCommandOptions } from './commands/SCAN';
import { HScanTuple } from './commands/HSCAN';
import { Options as PoolOptions } from 'generic-pool';
export interface RedisClientOptions<M = RedisModules, S = RedisLuaScripts> {
    socket?: RedisSocketOptions;
    modules?: M;
    scripts?: S;
    commandsQueueMaxLength?: number;
    readonly?: boolean;
    legacyMode?: boolean;
    isolationPoolOptions?: PoolOptions;
}
export declare type RedisCommandSignature<C extends RedisCommand> = (...args: Parameters<C['transformArguments']> | [options: CommandOptions<ClientCommandOptions>, ...rest: Parameters<C['transformArguments']>]) => Promise<ReturnType<C['transformReply']>>;
declare type WithCommands = {
    [P in keyof typeof COMMANDS]: RedisCommandSignature<(typeof COMMANDS)[P]>;
};
declare type WithModules<M extends RedisModules> = {
    [P in keyof M]: {
        [C in keyof M[P]]: RedisCommandSignature<M[P][C]>;
    };
};
declare type WithScripts<S extends RedisLuaScripts> = {
    [P in keyof S]: RedisCommandSignature<S[P]>;
};
export declare type WithPlugins<M extends RedisModules, S extends RedisLuaScripts> = WithCommands & WithModules<M> & WithScripts<S>;
export declare type RedisClientType<M extends RedisModules, S extends RedisLuaScripts> = WithPlugins<M, S> & RedisClient<M, S>;
export interface ClientCommandOptions extends QueueCommandOptions {
    isolated?: boolean;
}
export default class RedisClient<M extends RedisModules = RedisModules, S extends RedisLuaScripts = RedisLuaScripts> extends EventEmitter {
    #private;
    static commandOptions(options: ClientCommandOptions): CommandOptions<ClientCommandOptions>;
    static commandsExecutor(this: RedisClient, command: RedisCommand, args: Array<unknown>): Promise<ReturnType<typeof command['transformReply']>>;
    static create<M extends RedisModules, S extends RedisLuaScripts>(options?: RedisClientOptions<M, S>): RedisClientType<M, S>;
    get options(): RedisClientOptions<M> | null | undefined;
    get isOpen(): boolean;
    get v4(): Record<string, any>;
    constructor(options?: RedisClientOptions<M, S>);
    duplicate(): RedisClientType<M, S>;
    connect(): Promise<void>;
    SELECT(db: number): Promise<void>;
    SELECT(options: CommandOptions<ClientCommandOptions>, db: number): Promise<void>;
    select: {
        (db: number): Promise<void>;
        (options: CommandOptions<ClientCommandOptions>, db: number): Promise<void>;
    };
    SUBSCRIBE(channels: string | Array<string>, listener: PubSubListener): Promise<void>;
    subscribe: (channels: string | Array<string>, listener: PubSubListener) => Promise<void>;
    PSUBSCRIBE(patterns: string | Array<string>, listener: PubSubListener): Promise<void>;
    pSubscribe: (patterns: string | Array<string>, listener: PubSubListener) => Promise<void>;
    UNSUBSCRIBE(channels?: string | Array<string>, listener?: PubSubListener): Promise<void>;
    unsubscribe: (channels?: string | string[] | undefined, listener?: PubSubListener | undefined) => Promise<void>;
    PUNSUBSCRIBE(patterns?: string | Array<string>, listener?: PubSubListener): Promise<void>;
    pUnsubscribe: (patterns?: string | string[] | undefined, listener?: PubSubListener | undefined) => Promise<void>;
    sendCommand<T = unknown>(args: Array<string>, options?: ClientCommandOptions): Promise<T>;
    sendEncodedCommand<T = RedisReply>(encodedCommand: string, options?: ClientCommandOptions): Promise<T>;
    executeIsolated<T>(fn: (client: RedisClientType<M, S>) => T | Promise<T>): Promise<T>;
    executeScript(script: RedisLuaScript, args: Array<string>, options?: ClientCommandOptions): Promise<ReturnType<typeof script['transformReply']>>;
    multi(): RedisMultiCommandType<M, S>;
    scanIterator(options?: ScanCommandOptions): AsyncIterable<string>;
    hScanIterator(key: string, options?: ScanOptions): AsyncIterable<HScanTuple>;
    sScanIterator(key: string, options?: ScanOptions): AsyncIterable<string>;
    zScanIterator(key: string, options?: ScanOptions): AsyncIterable<ZMember>;
    disconnect(): Promise<void>;
}
export {};
