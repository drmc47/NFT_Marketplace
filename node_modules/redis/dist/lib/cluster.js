"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _RedisCluster_instances, _a, _RedisCluster_extractFirstKey, _RedisCluster_scriptsExecutor, _RedisCluster_options, _RedisCluster_slots, _RedisCluster_Multi, _RedisCluster_handleCommandError;
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = __importDefault(require("./client"));
const cluster_slots_1 = __importDefault(require("./cluster-slots"));
const commander_1 = require("./commander");
const multi_command_1 = __importDefault(require("./multi-command"));
class RedisCluster {
    constructor(options) {
        _RedisCluster_instances.add(this);
        _RedisCluster_options.set(this, void 0);
        _RedisCluster_slots.set(this, void 0);
        _RedisCluster_Multi.set(this, void 0);
        __classPrivateFieldSet(this, _RedisCluster_options, options, "f");
        __classPrivateFieldSet(this, _RedisCluster_slots, new cluster_slots_1.default(options), "f");
        __classPrivateFieldSet(this, _RedisCluster_Multi, multi_command_1.default.extend(options), "f");
    }
    static async commandsExecutor(command, args) {
        const { args: redisArgs, options } = commander_1.transformCommandArguments(command, args);
        const reply = command.transformReply(await this.sendCommand(__classPrivateFieldGet(RedisCluster, _a, "m", _RedisCluster_extractFirstKey).call(RedisCluster, command, args, redisArgs), command.IS_READ_ONLY, redisArgs, options), redisArgs.preserve);
        return reply;
    }
    static create(options) {
        return new (commander_1.extendWithModulesAndScripts({
            BaseClass: RedisCluster,
            modules: options === null || options === void 0 ? void 0 : options.modules,
            modulesCommandsExecutor: RedisCluster.commandsExecutor,
            scripts: options === null || options === void 0 ? void 0 : options.scripts,
            scriptsExecutor: __classPrivateFieldGet(RedisCluster, _a, "m", _RedisCluster_scriptsExecutor)
        }))(options);
    }
    async connect() {
        return __classPrivateFieldGet(this, _RedisCluster_slots, "f").connect();
    }
    async sendCommand(firstKey, isReadonly, args, options, redirections = 0) {
        const client = __classPrivateFieldGet(this, _RedisCluster_slots, "f").getClient(firstKey, isReadonly);
        try {
            return await client.sendCommand(args, options);
        }
        catch (err) {
            const shouldRetry = await __classPrivateFieldGet(this, _RedisCluster_instances, "m", _RedisCluster_handleCommandError).call(this, err, client, redirections);
            if (shouldRetry === true) {
                return this.sendCommand(firstKey, isReadonly, args, options, redirections + 1);
            }
            else if (shouldRetry) {
                return shouldRetry.sendCommand(args, options);
            }
            throw err;
        }
    }
    async executeScript(script, originalArgs, redisArgs, options, redirections = 0) {
        const client = __classPrivateFieldGet(this, _RedisCluster_slots, "f").getClient(__classPrivateFieldGet(RedisCluster, _a, "m", _RedisCluster_extractFirstKey).call(RedisCluster, script, originalArgs, redisArgs), script.IS_READ_ONLY);
        try {
            return await client.executeScript(script, redisArgs, options);
        }
        catch (err) {
            const shouldRetry = await __classPrivateFieldGet(this, _RedisCluster_instances, "m", _RedisCluster_handleCommandError).call(this, err, client, redirections);
            if (shouldRetry === true) {
                return this.executeScript(script, originalArgs, redisArgs, options, redirections + 1);
            }
            else if (shouldRetry) {
                return shouldRetry.executeScript(script, redisArgs, options);
            }
            throw err;
        }
    }
    multi(routing) {
        return new (__classPrivateFieldGet(this, _RedisCluster_Multi, "f"))(async (commands, chainId) => {
            const client = __classPrivateFieldGet(this, _RedisCluster_slots, "f").getClient(routing);
            return Promise.all(commands.map(({ encodedCommand }) => {
                return client.sendEncodedCommand(encodedCommand, client_1.default.commandOptions({
                    chainId
                }));
            }));
        }, __classPrivateFieldGet(this, _RedisCluster_options, "f"));
    }
    getMasters() {
        return __classPrivateFieldGet(this, _RedisCluster_slots, "f").getMasters();
    }
    getSlotMaster(slot) {
        return __classPrivateFieldGet(this, _RedisCluster_slots, "f").getSlotMaster(slot);
    }
    disconnect() {
        return __classPrivateFieldGet(this, _RedisCluster_slots, "f").disconnect();
    }
}
exports.default = RedisCluster;
_a = RedisCluster, _RedisCluster_options = new WeakMap(), _RedisCluster_slots = new WeakMap(), _RedisCluster_Multi = new WeakMap(), _RedisCluster_instances = new WeakSet(), _RedisCluster_extractFirstKey = function _RedisCluster_extractFirstKey(command, originalArgs, redisArgs) {
    if (command.FIRST_KEY_INDEX === undefined) {
        return undefined;
    }
    else if (typeof command.FIRST_KEY_INDEX === 'number') {
        return redisArgs[command.FIRST_KEY_INDEX];
    }
    return command.FIRST_KEY_INDEX(...originalArgs);
}, _RedisCluster_scriptsExecutor = async function _RedisCluster_scriptsExecutor(script, args) {
    const { args: redisArgs, options } = commander_1.transformCommandArguments(script, args);
    const reply = script.transformReply(await this.executeScript(script, args, redisArgs, options), redisArgs.preserve);
    return reply;
}, _RedisCluster_handleCommandError = async function _RedisCluster_handleCommandError(err, client, redirections) {
    var _b;
    if (redirections > ((_b = __classPrivateFieldGet(this, _RedisCluster_options, "f").maxCommandRedirections) !== null && _b !== void 0 ? _b : 16)) {
        throw err;
    }
    if (err.message.startsWith('ASK')) {
        const url = err.message.substring(err.message.lastIndexOf(' ') + 1);
        let node = __classPrivateFieldGet(this, _RedisCluster_slots, "f").getNodeByUrl(url);
        if (!node) {
            await __classPrivateFieldGet(this, _RedisCluster_slots, "f").discover(client);
            node = __classPrivateFieldGet(this, _RedisCluster_slots, "f").getNodeByUrl(url);
            if (!node) {
                throw new Error(`Cannot find node ${url}`);
            }
        }
        await node.client.asking();
        return node.client;
    }
    else if (err.message.startsWith('MOVED')) {
        await __classPrivateFieldGet(this, _RedisCluster_slots, "f").discover(client);
        return client;
    }
    throw err;
};
commander_1.extendWithDefaultCommands(RedisCluster, RedisCluster.commandsExecutor);
