"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _RedisSocket_instances, _a, _RedisSocket_initiateOptions, _RedisSocket_defaultReconnectStrategy, _RedisSocket_isUrlSocket, _RedisSocket_isUnixSocket, _RedisSocket_isTlsSocket, _RedisSocket_initiator, _RedisSocket_options, _RedisSocket_socket, _RedisSocket_isOpen, _RedisSocket_connect, _RedisSocket_retryConnection, _RedisSocket_createSocket, _RedisSocket_createNetSocket, _RedisSocket_createTlsSocket, _RedisSocket_onSocketError;
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const net_1 = __importDefault(require("net"));
const tls_1 = __importDefault(require("tls"));
const url_1 = require("url");
const utils_1 = require("./utils");
class RedisSocket extends events_1.default {
    constructor(initiator, options) {
        super();
        _RedisSocket_instances.add(this);
        _RedisSocket_initiator.set(this, void 0);
        _RedisSocket_options.set(this, void 0);
        _RedisSocket_socket.set(this, void 0);
        _RedisSocket_isOpen.set(this, false);
        __classPrivateFieldSet(this, _RedisSocket_initiator, initiator, "f");
        __classPrivateFieldSet(this, _RedisSocket_options, __classPrivateFieldGet(RedisSocket, _a, "m", _RedisSocket_initiateOptions).call(RedisSocket, options), "f");
    }
    get isOpen() {
        return __classPrivateFieldGet(this, _RedisSocket_isOpen, "f");
    }
    get chunkRecommendedSize() {
        if (!__classPrivateFieldGet(this, _RedisSocket_socket, "f"))
            return 0;
        return __classPrivateFieldGet(this, _RedisSocket_socket, "f").writableHighWaterMark - __classPrivateFieldGet(this, _RedisSocket_socket, "f").writableLength;
    }
    async connect() {
        if (__classPrivateFieldGet(this, _RedisSocket_isOpen, "f")) {
            throw new Error('Socket is connection/connecting');
        }
        __classPrivateFieldSet(this, _RedisSocket_isOpen, true, "f");
        try {
            await __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_connect).call(this);
        }
        catch (err) {
            __classPrivateFieldSet(this, _RedisSocket_isOpen, false, "f");
            throw err;
        }
    }
    write(encodedCommands) {
        if (!__classPrivateFieldGet(this, _RedisSocket_socket, "f")) {
            throw new Error('Socket is closed');
        }
        return __classPrivateFieldGet(this, _RedisSocket_socket, "f").write(encodedCommands);
    }
    async disconnect() {
        if (!__classPrivateFieldGet(this, _RedisSocket_isOpen, "f") || !__classPrivateFieldGet(this, _RedisSocket_socket, "f")) {
            throw new Error('Socket is closed');
        }
        __classPrivateFieldSet(this, _RedisSocket_isOpen, false, "f");
        __classPrivateFieldGet(this, _RedisSocket_socket, "f").end();
        await events_1.default.once(__classPrivateFieldGet(this, _RedisSocket_socket, "f"), 'end');
        __classPrivateFieldSet(this, _RedisSocket_socket, undefined, "f");
        this.emit('end');
    }
}
exports.default = RedisSocket;
_a = RedisSocket, _RedisSocket_initiator = new WeakMap(), _RedisSocket_options = new WeakMap(), _RedisSocket_socket = new WeakMap(), _RedisSocket_isOpen = new WeakMap(), _RedisSocket_instances = new WeakSet(), _RedisSocket_initiateOptions = function _RedisSocket_initiateOptions(options) {
    var _b, _c;
    var _d, _e;
    options !== null && options !== void 0 ? options : (options = {});
    if (!__classPrivateFieldGet(RedisSocket, _a, "m", _RedisSocket_isUnixSocket).call(RedisSocket, options)) {
        if (__classPrivateFieldGet(RedisSocket, _a, "m", _RedisSocket_isUrlSocket).call(RedisSocket, options)) {
            const url = new url_1.URL(options.url);
            options.port = Number(url.port);
            options.host = url.hostname;
            options.username = url.username;
            options.password = url.password;
        }
        (_b = (_d = options).port) !== null && _b !== void 0 ? _b : (_d.port = 6379);
        (_c = (_e = options).host) !== null && _c !== void 0 ? _c : (_e.host = '127.0.0.1');
    }
    return options;
}, _RedisSocket_defaultReconnectStrategy = function _RedisSocket_defaultReconnectStrategy(retries) {
    return Math.min(retries * 50, 500);
}, _RedisSocket_isUrlSocket = function _RedisSocket_isUrlSocket(options) {
    return Object.prototype.hasOwnProperty.call(options, 'url');
}, _RedisSocket_isUnixSocket = function _RedisSocket_isUnixSocket(options) {
    return Object.prototype.hasOwnProperty.call(options, 'path');
}, _RedisSocket_isTlsSocket = function _RedisSocket_isTlsSocket(options) {
    return Object.prototype.hasOwnProperty.call(options, 'tls');
}, _RedisSocket_connect = async function _RedisSocket_connect(hadError) {
    __classPrivateFieldSet(this, _RedisSocket_socket, await __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_retryConnection).call(this, 0, hadError), "f");
    this.emit('connect');
    if (__classPrivateFieldGet(this, _RedisSocket_initiator, "f")) {
        try {
            await __classPrivateFieldGet(this, _RedisSocket_initiator, "f").call(this);
        }
        catch (err) {
            __classPrivateFieldGet(this, _RedisSocket_socket, "f").end();
            __classPrivateFieldSet(this, _RedisSocket_socket, undefined, "f");
            throw err;
        }
    }
    this.emit('ready');
}, _RedisSocket_retryConnection = async function _RedisSocket_retryConnection(retries, hadError) {
    var _b, _c;
    if (retries > 0 || hadError) {
        this.emit('reconnecting');
    }
    try {
        return await __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_createSocket).call(this);
    }
    catch (err) {
        this.emit('error', err);
        if (!__classPrivateFieldGet(this, _RedisSocket_isOpen, "f")) {
            throw err;
        }
        const retryIn = ((_c = (_b = __classPrivateFieldGet(this, _RedisSocket_options, "f")) === null || _b === void 0 ? void 0 : _b.reconnectStrategy) !== null && _c !== void 0 ? _c : __classPrivateFieldGet(RedisSocket, _a, "m", _RedisSocket_defaultReconnectStrategy))(retries);
        if (retryIn instanceof Error) {
            throw retryIn;
        }
        await utils_1.promiseTimeout(retryIn);
        return __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_retryConnection).call(this, retries + 1);
    }
}, _RedisSocket_createSocket = function _RedisSocket_createSocket() {
    return new Promise((resolve, reject) => {
        const { connectEvent, socket } = __classPrivateFieldGet(RedisSocket, _a, "m", _RedisSocket_isTlsSocket).call(RedisSocket, __classPrivateFieldGet(this, _RedisSocket_options, "f")) ?
            __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_createTlsSocket).call(this) :
            __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_createNetSocket).call(this);
        socket
            .setNoDelay()
            .once('error', (err) => reject(err))
            .once(connectEvent, () => {
            socket
                .off('error', reject)
                .once('error', (err) => __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_onSocketError).call(this, err))
                .once('close', hadError => {
                if (!hadError && __classPrivateFieldGet(this, _RedisSocket_isOpen, "f")) {
                    __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_onSocketError).call(this, new Error('Socket closed unexpectedly'));
                }
            })
                .on('drain', () => this.emit('drain'))
                .on('data', (data) => this.emit('data', data));
            resolve(socket);
        });
    });
}, _RedisSocket_createNetSocket = function _RedisSocket_createNetSocket() {
    return {
        connectEvent: 'connect',
        socket: net_1.default.connect(__classPrivateFieldGet(this, _RedisSocket_options, "f")) // TODO
    };
}, _RedisSocket_createTlsSocket = function _RedisSocket_createTlsSocket() {
    return {
        connectEvent: 'secureConnect',
        socket: tls_1.default.connect(__classPrivateFieldGet(this, _RedisSocket_options, "f")) // TODO
    };
}, _RedisSocket_onSocketError = function _RedisSocket_onSocketError(err) {
    __classPrivateFieldSet(this, _RedisSocket_socket, undefined, "f");
    this.emit('error', err);
    __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_connect).call(this, true)
        .catch(err => this.emit('error', err));
};
